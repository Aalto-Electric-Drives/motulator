"""
3-phase AC voltage source models.

Two voltage sources with variable voltage magnitude, to simulate voltage dips
and symmetrical short circuits are modeled. A stiff model with a constant
frequency and a dynamic model with the electromechanical dynamics of a
synchronous generator are considered. In this module, all space vectors are in
stationary coordinates.

The grid angle theta_g is used 
    as state variables.

        theta_g = w_N * t

"""
from types import SimpleNamespace

import numpy as np

from motulator.common.model import Subsystem
from motulator.common.utils._utils import (complex2abc, abc2complex)

# %%
class StiffSource(Subsystem):
    """
    Grid subsystem.

    This model is a constant frequency 3-phase voltage source of the AC grid.

    Parameters
    ----------
    w_N : float
        grid constant frequency (rad/s).
    e_g_abs : function
        3-phase grid voltage magnitude, phase-to-ground peak value (V).
    """

    def __init__(self, w_N=2*np.pi*50,
                 e_g_abs=lambda t: 400*np.sqrt(2/3)):
        super().__init__()
        self.par = SimpleNamespace(w_N=w_N, e_g_abs=e_g_abs)
        # states
        self.state = SimpleNamespace(exp_j_theta_g=complex(1))
        # Store the solutions in these lists
        self.sol_states = SimpleNamespace(exp_j_theta_g=[])

    @property
    def w_N(self):
        """Grid constant frequency (rad/s)."""
        if callable(self.par.w_N):
            return self.par.w_N()
        return self.par.w_N

    def rhs(self):
        """
        Compute the state derivatives.
        
        Returns
        -------
        list, length 1
            Time derivatives of the state vector.
            
        """
        d_exp_j_theta_g = 1j*self.par.w_N*self.state.exp_j_theta_g
        return [d_exp_j_theta_g]

    def voltages(self, t, theta_g):
        """
        Compute the grid voltage in stationary frame.
           
        Parameters
        ----------
        t : float
            Time (s).
        theta_g : float
            Grid voltage angle (rad)

        Returns
        -------
        e_gs: complex
            grid complex voltage (V).

        """

        # Calculation of the three-phase voltages
        e_g_a = self.par.e_g_abs(t)*np.cos(theta_g)
        e_g_b = self.par.e_g_abs(t)*np.cos(theta_g-2*np.pi/3)
        e_g_c = self.par.e_g_abs(t)*np.cos(theta_g-4*np.pi/3)

        e_gs = abc2complex([e_g_a, e_g_b, e_g_c])
        return e_gs

    def set_outputs(self, t):
        """Set output variables."""
        self.out.e_gs = self.voltages(t, np.angle(self.state.exp_j_theta_g))

    def meas_voltages(self, t):
        """
        Measure the phase voltages at the end of the sampling period.
        
        Parameters
        ----------
        t : float
            Time (s).

        Returns
        -------
        e_g_abc : 3-tuple of floats
            Phase voltages (V).

        """
        # Grid voltage
        e_g_abc = complex2abc(self.voltages(t, np.angle(self.state.exp_j_theta_g)))
        return e_g_abc

    def post_process_states(self):
        """Post-process the solution."""
        self.data.theta_g = np.angle(self.data.exp_j_theta_g)
        self.data.e_gs=self.voltages(self.data.t, self.data.theta_g)


# %%
class FlexSource(Subsystem):
    """
    Grid subsystem.
    
    This models the 3-phase voltage source of the AC grid while taking into
    account the electromechanical dynamics of a typical grid generated by the 
    synchronous generators.
    
    More information about the model can be found in [#ENT2013].
    
    [#ENT2013] : ENTSO-E, Documentation on Controller Tests in Test Grid
    Configurations, Technical Report, 26.11.2013.
    
    Parameters
    ----------
    T_D : float
        turbine delay time constant (s).
    T_N : float
        turbine derivative time constant (s).
    H_g : float
        grid inertia constant (s).
    r_d : float
        primary frequency droop control gain (p.u.).
    T_gov : float
        governor time constant (s).
    w_N : float
        grid constant frequency (rad/s).
    S_grid : float
        grid rated power (VA).
    e_g_abs : function
        3-phase grid voltage magnitude, phase-to-ground peak value (V).
    p_m_ref : function
        mechanical power output reference (W).
    p_e : function
        electrical power disturbance (W).
        
    """
    def __init__(
            self, T_D=10,
            T_N=3,
            H_g=3,
            D_g=0,
            r_d=.05,
            T_gov=0.5,
            w_N=2*np.pi*50,
            S_grid =500e6,
            e_g_abs=lambda t: 400*np.sqrt(2/3),
            p_m_ref=lambda t: 0,
            p_e=lambda t: 0):
        
        super().__init__()
        self.par = SimpleNamespace(
            T_D=T_D, T_N=T_N, H_g=H_g, D_g=D_g, r_d=r_d, T_gov=T_gov, w_N=w_N,
            S_grid=S_grid, e_g_abs=e_g_abs, p_m_ref=p_m_ref, p_e=p_e)
        
        # Initial values
        self.w_g0 = w_N
        self.err_w_g0, self.p_gov0, self.x_turb0, self.theta_g0 = 0, 0, 0, 0

    def f(self, t, err_w_g, p_gov, x_turb):
        """
        Compute the state derivatives.
        
        Parameters
        ----------
        t : float
            Time (s).
        err_w_g : float
            grid angular speed deviation (mechanical rad/s).
        p_gov : float
            governor output power (W).
        x_turb : float
            turbine state variable (W).
        p_e : float
            electrical power disturbance (W).
        Returns
        -------
        list, length 4
            Time derivatives of the state vector.
            
        """
        # calculation of mechanical power from the turbine output
        p_m = (self.T_N/self.T_D)*p_gov + (1-(self.T_N/self.T_D))*x_turb
        # swing equation
        p_diff = (p_m - self.p_e(t))/self.S_grid # in per units
        derr_w_g = self.w_N*(p_diff - self.D_g*err_w_g)/(2*self.H_g)
        # governor dynamics
        dp_gov = (self.p_m_ref(t) - (1/self.r_d)*err_w_g - p_gov) / self.T_gov
        # turbine dynamics (lead-lag)
        dx_turb = (p_gov - x_turb)/self.T_D
        # integration of the angle
        dtheta_g = self.w_N + err_w_g
        return [derr_w_g, dp_gov, dx_turb, dtheta_g]

    def voltages(self, t, theta_g):
        """
        Compute the grid voltage in stationary frame:
           
        Parameters
        ----------
        t : float
            Time.
        theta_g : float
            grid electrical angle (rad).

        Returns
        -------
        e_gs: complex
            grid complex voltage (V).

        """
        # Calculation of the three-phase voltage
        e_g_a = self.e_g_abs(t)*np.cos(theta_g)
        e_g_b = self.e_g_abs(t)*np.cos(theta_g-2*np.pi/3)
        e_g_c = self.e_g_abs(t)*np.cos(theta_g-4*np.pi/3)


        e_gs = abc2complex([e_g_a, e_g_b, e_g_c])
        return e_gs


    def meas_voltages(self, t):
        """
        Measure the phase voltages at the end of the sampling period.

        Returns
        -------
        e_g_abc : 3-tuple of floats
            Phase voltages (V).

        """
        # Grid voltage
        e_g_abc = complex2abc(self.voltages(t))
        return e_g_abc


    def meas_freq(self):
        """
        Measure the grid frequency.
        
        This returns the grid frequency at the end of the sampling period.
        
        Returns
        -------
        w_g0 : float
            Grid angular speed (rad/s).
            
        """
        w_g0 = self.w_g0
        return w_g0

    def meas_angle(self):
        """
        Measure the grid angle.
        
        This returns the grid angle at the end of the sampling period.
        
        Returns
        -------
        theta_g0 : float
            grid electrical angle (rad).
            
        """
        return self.theta_g0
