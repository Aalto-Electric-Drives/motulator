
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/obs_vhz/plot_obs_vhz_ctrl_pmsyrm_thor.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_obs_vhz_plot_obs_vhz_ctrl_pmsyrm_thor.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_obs_vhz_plot_obs_vhz_ctrl_pmsyrm_thor.py:


5-kW PM-SyRM, flux maps from SyR-e
==================================

This example simulates observer-based V/Hz control of a saturated 5-kW
permanent-magnet synchronous reluctance motor. The flux maps of this example
motor, known as THOR, are from the SyR-e project:

    https://github.com/SyR-e/syre_public

The SyR-e project has been licensed under the Apache License, Version 2.0. We
acknowledge the developers of the SyR-e project. The flux maps from other
sources can be used in a similar manner. It is worth noticing that the 
saturation is not taken into account in the control method, only in the system 
model. Naturally, the control performance could be improved by taking the
saturation into account in the control algorithm.

.. GENERATED FROM PYTHON SOURCE LINES 20-29

.. code-block:: Python


    from os import path
    import inspect
    import numpy as np
    from scipy.optimize import minimize_scalar
    from scipy.interpolate import LinearNDInterpolator
    from motulator import model, control
    from motulator import BaseValues, NominalValues, Sequence, plot








.. GENERATED FROM PYTHON SOURCE LINES 30-31

Compute base values based on the nominal values (just for figures).

.. GENERATED FROM PYTHON SOURCE LINES 31-35

.. code-block:: Python


    nom = NominalValues(U=220, I=15.6, f=85, P=5.07e3, tau=19)
    base = BaseValues.from_nominal(nom, n_p=2)








.. GENERATED FROM PYTHON SOURCE LINES 36-37

Load and plot the flux maps.

.. GENERATED FROM PYTHON SOURCE LINES 37-52

.. code-block:: Python


    # Get the path of this file
    p = path.dirname(path.abspath(inspect.getfile(inspect.currentframe())))
    # Load the data from the MATLAB file
    data = model.import_syre_data(p + "/THOR.mat")

    # You may also downsample or invert the flux map by uncommenting the following
    # lines. Not needed here, but these methods could be useful for other purposes.

    # from motulator.model.sm_flux_maps import downsample_flux_map, invert_flux_map
    # data = downsample_flux_map(data, N_d=32, N_q=32)
    # data = invert_flux_map(data, N_d=128, N_q=128)
    model.plot_flux_vs_current(data)
    model.plot_flux_map(data)




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_001.png
         :alt: plot obs vhz ctrl pmsyrm thor
         :srcset: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_002.png
         :alt: plot obs vhz ctrl pmsyrm thor
         :srcset: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_002.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 53-54

Create the saturation model.

.. GENERATED FROM PYTHON SOURCE LINES 54-81

.. code-block:: Python


    # The coordinates assume the PMSM convention, i.e., that the PM flux is along
    # the d-axis. The piecewise linear interpolant `LinearNDInterpolator` is based
    # on triangularization and allows to use unstructured flux maps.

    # Data points for creating the interpolant
    psi_s_data = np.asarray(data.psi_s).ravel()
    i_s_data = np.asarray(data.i_s).ravel()

    # Create the interpolant, i_s = current_dq(psi_s.real, psi_s.imag)
    current_dq = LinearNDInterpolator(
        list(zip(psi_s_data.real, psi_s_data.imag)), i_s_data)

    # Solve the PM flux for the initial value of the stator flux
    res = minimize_scalar(
        lambda psi_d: np.abs(current_dq(psi_d, 0)),
        bounds=(0, np.max(psi_s_data.real)),
        method="bounded")
    psi_s0 = complex(res.x)


    # Package the input such that i_s = i_s(psi_s)
    def i_s(psi_s):
        """Current as a function of the flux linkage."""
        return current_dq(psi_s.real, psi_s.imag)









.. GENERATED FROM PYTHON SOURCE LINES 82-83

Configure the system model.

.. GENERATED FROM PYTHON SOURCE LINES 83-93

.. code-block:: Python


    # Create the motor model
    machine = model.SynchronousMachine(n_p=2, R_s=.2, i_s=i_s, psi_s0=psi_s0)
    # Magnetically linear PM-SyRM model
    # machine = model.sm.SynchronousMachine(
    #     n_p=2, R_s=.2, L_d=4e-3, L_q=17e-3, psi_f=.134)
    mechanics = model.Mechanics(J=.0042)
    converter = model.Inverter(u_dc=310)
    mdl = model.Drive(converter, machine, mechanics)








.. GENERATED FROM PYTHON SOURCE LINES 94-95

Configure the control system.

.. GENERATED FROM PYTHON SOURCE LINES 95-100

.. code-block:: Python


    par = control.sm.ModelPars(n_p=2, R_s=.2, L_d=4e-3, L_q=17e-3, psi_f=.134)
    cfg = control.sm.ObserverBasedVHzCtrlCfg(par, max_i_s=2*base.i)
    ctrl = control.sm.ObserverBasedVHzCtrl(par, cfg, T_s=250e-6)








.. GENERATED FROM PYTHON SOURCE LINES 101-102

Set the speed reference and the external load torque.

.. GENERATED FROM PYTHON SOURCE LINES 102-117

.. code-block:: Python


    # Speed reference
    times = np.array([0, .125, .25, .375, .5, .625, .75, .875, 1])*8
    values = np.array([0, 0, 1, 1, 0, -1, -1, 0, 0])*base.w
    ctrl.ref.w_m = Sequence(times, values)

    # Quadratic load torque profile (corresponding to pumps and fans)
    k = nom.tau/(base.w/base.n_p)**2
    mdl.mechanics.tau_L_w = lambda w_M: k*w_M**2*np.sign(w_M)

    # Uncomment to try the rated load torque step at t = 1 s (set k = 0 above)
    # times = np.array([0, .125, .125, .875, .875, 1])*8
    # values = np.array([0, 0, 1, 1, 0, 0])*nom.tau
    # mdl.mechanics.tau_L_t = Sequence(times, values)








.. GENERATED FROM PYTHON SOURCE LINES 118-119

Create the simulation object and simulate it.

.. GENERATED FROM PYTHON SOURCE LINES 119-123

.. code-block:: Python


    sim = model.Simulation(mdl, ctrl)
    sim.simulate(t_stop=8)








.. GENERATED FROM PYTHON SOURCE LINES 124-126

Plot results in per-unit values. By omitting the argument `base` you can plot
the results in SI units.

.. GENERATED FROM PYTHON SOURCE LINES 126-128

.. code-block:: Python


    plot(sim, base)



.. image-sg:: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_003.png
   :alt: plot obs vhz ctrl pmsyrm thor
   :srcset: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_003.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 52.403 seconds)


.. _sphx_glr_download_auto_examples_obs_vhz_plot_obs_vhz_ctrl_pmsyrm_thor.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_obs_vhz_ctrl_pmsyrm_thor.ipynb <plot_obs_vhz_ctrl_pmsyrm_thor.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_obs_vhz_ctrl_pmsyrm_thor.py <plot_obs_vhz_ctrl_pmsyrm_thor.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
