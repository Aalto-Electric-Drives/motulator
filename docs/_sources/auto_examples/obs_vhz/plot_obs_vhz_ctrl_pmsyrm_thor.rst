
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/obs_vhz/plot_obs_vhz_ctrl_pmsyrm_thor.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_obs_vhz_plot_obs_vhz_ctrl_pmsyrm_thor.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_obs_vhz_plot_obs_vhz_ctrl_pmsyrm_thor.py:


5-kW PM-SyRM, flux maps from SyR-e
==================================

This example simulates observer-based V/Hz control of a saturated 5-kW
permanent-magnet synchronous reluctance motor. The flux maps of this example
motor, known as THOR, are from the SyR-e project:

    https://github.com/SyR-e/syre_public

The SyR-e project has been licensed under the Apache License, Version 2.0. We
acknowledge the developers of the SyR-e project. The flux maps from other
sources can be used in a similar manner. It is worth noticing that the 
saturation is not taken into account in the control method, only in the system 
model. Naturally, the control performance could be improved by taking the
saturation into account in the control algorithm.

.. GENERATED FROM PYTHON SOURCE LINES 21-22

Imports.

.. GENERATED FROM PYTHON SOURCE LINES 22-31

.. code-block:: Python


    from os import path
    import inspect
    import numpy as np
    from scipy.optimize import minimize_scalar
    from scipy.interpolate import LinearNDInterpolator
    from motulator import model, control
    from motulator import BaseValues, Sequence, plot








.. GENERATED FROM PYTHON SOURCE LINES 32-33

Compute base values based on the nominal values (just for figures).

.. GENERATED FROM PYTHON SOURCE LINES 33-37

.. code-block:: Python


    base = BaseValues(
        U_nom=220, I_nom=15.6, f_nom=85, tau_nom=19, P_nom=5.07e3, n_p=2)








.. GENERATED FROM PYTHON SOURCE LINES 38-39

Load and plot the flux maps.

.. GENERATED FROM PYTHON SOURCE LINES 39-54

.. code-block:: Python


    # Get the path of this file
    p = path.dirname(path.abspath(inspect.getfile(inspect.currentframe())))
    # Load the data from the MATLAB file
    data = model.sm.import_syre_data(p + "/THOR.mat")

    # You may also downsample or invert the flux map by uncommenting the following
    # lines. Not needed here, but these methods could be useful for other purposes.

    # from motulator.model.sm_flux_maps import downsample_flux_map, invert_flux_map
    # data = downsample_flux_map(data, N_d=32, N_q=32)
    # data = invert_flux_map(data, N_d=128, N_q=128)
    model.sm.plot_flux_vs_current(data)
    model.sm.plot_flux_map(data)




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_001.png
         :alt: plot obs vhz ctrl pmsyrm thor
         :srcset: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_002.png
         :alt: plot obs vhz ctrl pmsyrm thor
         :srcset: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_002.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 55-56

Create the saturation model.

.. GENERATED FROM PYTHON SOURCE LINES 56-82

.. code-block:: Python


    # The coordinates assume the PMSM convention, i.e., that the PM flux is along
    # the d-axis. The piecewise linear interpolant `LinearNDInterpolator` is based
    # on triangularization and allows to use unstructured flux maps.

    # Data points for creating the interpolant
    psi_s_data, i_s_data = data.psi_s.ravel(), data.i_s.ravel()

    # Create the interpolant, i_s = current_dq(psi_s.real, psi_s.imag)
    current_dq = LinearNDInterpolator(
        list(zip(psi_s_data.real, psi_s_data.imag)), i_s_data)

    # Solve the PM flux for the initial value of the stator flux
    res = minimize_scalar(
        lambda psi_d: np.abs(current_dq(psi_d, 0)),
        bounds=(0, np.max(psi_s_data.real)),
        method="bounded")
    psi_s0 = complex(res.x)


    # Package the input such that i_s = i_s(psi_s)
    def i_s(psi_s):
        """Current as a function of the flux linkage."""
        return current_dq(psi_s.real, psi_s.imag)









.. GENERATED FROM PYTHON SOURCE LINES 83-84

Configure the system model.

.. GENERATED FROM PYTHON SOURCE LINES 84-95

.. code-block:: Python


    # Create the motor model
    machine = model.sm.SynchronousMachineSaturated(
        n_p=2, R_s=.2, current=i_s, psi_s0=psi_s0)
    # Magnetically linear PM-SyRM model
    # machine = model.sm.SynchronousMachine(
    #     n_p=2, R_s=.2, L_d=4e-3, L_q=17e-3, psi_f=.134)
    mechanics = model.Mechanics(J=.0042)
    converter = model.Inverter(u_dc=310)
    mdl = model.sm.Drive(machine, mechanics, converter)








.. GENERATED FROM PYTHON SOURCE LINES 96-97

Configure the control system.

.. GENERATED FROM PYTHON SOURCE LINES 97-102

.. code-block:: Python


    par = control.sm.ModelPars(n_p=2, R_s=.2, L_d=4e-3, L_q=17e-3, psi_f=.134)
    ctrl_par = control.sm.ObserverBasedVHzCtrlPars(par, i_s_max=2*base.i)
    ctrl = control.sm.ObserverBasedVHzCtrl(par, ctrl_par, T_s=250e-6)








.. GENERATED FROM PYTHON SOURCE LINES 103-104

Set the speed reference and the external load torque.

.. GENERATED FROM PYTHON SOURCE LINES 104-119

.. code-block:: Python


    # Speed reference
    times = np.array([0, .125, .25, .375, .5, .625, .75, .875, 1])*8
    values = np.array([0, 0, 1, 1, 0, -1, -1, 0, 0])*base.w
    ctrl.w_m_ref = Sequence(times, values)

    # Quadratic load torque profile (corresponding to pumps and fans)
    k = base.tau_nom/(base.w/base.n_p)**2
    mdl.mechanics.tau_L_w = lambda w_M: k*w_M**2*np.sign(w_M)

    # Uncomment to try the rated load torque step at t = 1 s (set k = 0 above)
    # times = np.array([0, .125, .125, .875, .875, 1])*8
    # values = np.array([0, 0, 1, 1, 0, 0])*base.tau_nom
    # mdl.mechanics.tau_L_t = Sequence(times, values)








.. GENERATED FROM PYTHON SOURCE LINES 120-123

Create the simulation object and simulate it. You can also enable the PWM
model (which makes simulation slower). One-sampling-period computational
delay is modeled.

.. GENERATED FROM PYTHON SOURCE LINES 123-127

.. code-block:: Python


    sim = model.Simulation(mdl, ctrl, pwm=False, delay=1)
    sim.simulate(t_stop=8)








.. GENERATED FROM PYTHON SOURCE LINES 128-130

Plot results in per-unit values. By omitting the argument `base` you can plot
the results in SI units.

.. GENERATED FROM PYTHON SOURCE LINES 130-132

.. code-block:: Python


    plot(sim, base)



.. image-sg:: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_003.png
   :alt: plot obs vhz ctrl pmsyrm thor
   :srcset: /auto_examples/obs_vhz/images/sphx_glr_plot_obs_vhz_ctrl_pmsyrm_thor_003.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 31.716 seconds)


.. _sphx_glr_download_auto_examples_obs_vhz_plot_obs_vhz_ctrl_pmsyrm_thor.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_obs_vhz_ctrl_pmsyrm_thor.ipynb <plot_obs_vhz_ctrl_pmsyrm_thor.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_obs_vhz_ctrl_pmsyrm_thor.py <plot_obs_vhz_ctrl_pmsyrm_thor.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
